

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Hexo/img/csdn.png">
  <link rel="icon" href="/Hexo/img/csdn.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#DAA520">
  <meta name="author" content="星">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java核心技术部分1、面向对象的特征有哪些？面向对象的三大特征： 继承：通过继承允许复用已有的类，继承关系是一种“一般到特殊”的关系，比如苹果类继承水果类，这个过程称为类继承。 派生出来的新类称为原有类的子类（派生类），而原有类称为新类的父类（基类）。 子类可以从父类那里继承得到方法和成员变量，而且子类类可以修改或增加新的方法使之适合子类的需要。 封装：封装是把对象的状态数据隐藏起来，再通过暴露">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java基础面试题》">
<meta property="og:url" content="https://1902756969.github.io/Hexo/2021/03/21/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8B/index.html">
<meta property="og:site_name" content="阿星的博客">
<meta property="og:description" content="Java核心技术部分1、面向对象的特征有哪些？面向对象的三大特征： 继承：通过继承允许复用已有的类，继承关系是一种“一般到特殊”的关系，比如苹果类继承水果类，这个过程称为类继承。 派生出来的新类称为原有类的子类（派生类），而原有类称为新类的父类（基类）。 子类可以从父类那里继承得到方法和成员变量，而且子类类可以修改或增加新的方法使之适合子类的需要。 封装：封装是把对象的状态数据隐藏起来，再通过暴露">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/623e9bfa27f86abb2aee7d5e.png">
<meta property="article:published_time" content="2021-03-21T10:29:54.000Z">
<meta property="article:modified_time" content="2022-10-02T10:04:57.187Z">
<meta property="article:author" content="星">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/623e9bfa27f86abb2aee7d5e.png">
  
  
  <title>《Java基础面试题》 - 阿星的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Hexo/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/Hexo/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/Hexo/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"1902756969.github.io","root":"/Hexo/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":" ❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Hexo/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/Hexo/js/utils.js" ></script>
  <script  src="/Hexo/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Hexo/">
      <strong>🐛 ZhaFi人</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Hexo/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Hexo/img/bg5.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="《Java基础面试题》"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        星
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-03-21 18:29" pubdate>
          2021年3月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          113 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《Java基础面试题》</h1>
            
            <div class="markdown-body">
              
              <h2 id="Java核心技术部分"><a href="#Java核心技术部分" class="headerlink" title="Java核心技术部分"></a>Java核心技术部分</h2><h3 id="1、面向对象的特征有哪些？"><a href="#1、面向对象的特征有哪些？" class="headerlink" title="1、面向对象的特征有哪些？"></a>1、面向对象的特征有哪些？</h3><p>面向对象的三大特征：</p>
<p><strong>继承：</strong>通过继承允许复用已有的类，继承关系是一种“一般到特殊”的关系，比如苹果类继承水果类，这个过程称为类继承。</p>
<p>派生出来的新类称为原有类的子类（派生类），而原有类称为新类的父类（基类）。</p>
<p>子类可以从父类那里继承得到方法和成员变量，而且子类类可以修改或增加新的方法使之适合子类的需要。</p>
<p><strong>封装：</strong>封装是把对象的状态数据隐藏起来，再通过暴露合适的方法来允许外部程序修改对象的状态数据。Java的封装主要通过private、protected、public等访问控制符来实现。</p>
<p><strong>多态性：</strong>多态指的是当同一个类型的引用类型的变量在执行相同的方法时，实际上会呈现出多种不同的行为特征。比如程序有Animal a1 &#x3D; new Animal (); Animal a2 &#x3D; new Wolf();虽然a1、a2两个引用变量的类型都是Animal，但当它们调用同一个run()方法时，如果Wolf()类重写过Animal的run()方法，这就会导致a1、a2两个变量执行run()方法时呈现出不同的行为特征，这就是多态。多态增加了编程的灵活性，实际上大量设计模式都是基于多态类实现的。</p>
<p>除此之外，<strong>抽象</strong>也是一个重要的特征，抽象就是忽略与当前目标无关的相关方面，以便更充分地突出与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<h3 id="2、Java中实现多态的机制是什么？"><a href="#2、Java中实现多态的机制是什么？" class="headerlink" title="2、Java中实现多态的机制是什么？"></a>2、Java中实现多态的机制是什么？</h3><p>Java允许父类或接口定义的引用变量指向子类或具体实现类的实例对象，而程序调用的方法在运行时才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<p>正是由于这种机制，两个相同类型的变量，但由于它们实际引用了不同的</p>
<h3 id="3、一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#3、一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="3、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>3、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件的主文件名相同。</p>
<p>包含多个类的Java源文件编译之后会生成多个.class文件。</p>
<h3 id="4、String是基本数据类型吗"><a href="#4、String是基本数据类型吗" class="headerlink" title="4、String是基本数据类型吗?"></a>4、String是基本数据类型吗?</h3><p>基本数据类型包括byte、short、int、long、char、float、double和boolean。String不是基本类型。String是引用类型。</p>
<p>而且java.lang.String类是final类型的，因此不可以继承这个类。</p>
<p>并且它是一个不可变类，因此如果程序需要使用的字符串所包含的字符序列需要经常改变，建议使用StringBuffer（线程安全、性能略差）类或StringBuilder类。</p>
<h3 id="5、int-和-Integer-有什么区别"><a href="#5、int-和-Integer-有什么区别" class="headerlink" title="5、int 和 Integer 有什么区别"></a>5、int 和 Integer 有什么区别</h3><p>Java 提供两种不同的类型：引用类型和基本数据类型。</p>
<p>int是基本数据类型，Integer是java为int提供的包装类。</p>
<p>Java为每个原始类型提供了包装类。</p>
<p>byte   Byte </p>
<p>short   Short </p>
<p>int    Integer </p>
<p>long   Long </p>
<p>char   Character </p>
<p>float   Float </p>
<p>double  Double </p>
<p>boolean  Boolean </p>
<p>基本类型的变量只能当成简单的直接量、参与表达式运算，不具备面向对对象的特征，基本类型的变量不能被赋为null；但包装类的变量则完全可以当成对象使用，它具有面向对象的特征，包装类的变量可以被赋为null。</p>
<p>因为Integer具有面向对象的特征，因此Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用EL输出为null的Integer时，将会显示为空白字符串，而int默认的默认值为0，用EL输出为将显示0。所以，int不适合作为Web层的表单数据的类型。</p>
<p>从Java 5开始，Java提供了自动装箱、自动拆箱功能，因此包装类也可以直接参与表达式运算，因此使用起来十分方便。</p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="6、Java有没有goto"><a href="#6、Java有没有goto" class="headerlink" title="6、Java有没有goto?"></a>6、Java有没有goto?</h3><p>goto是Java中的保留字，暂时还不是Java的关键字。</p>
<h3 id="7、String-和StringBuffer、StringBuilder的区别"><a href="#7、String-和StringBuffer、StringBuilder的区别" class="headerlink" title="7、String 和StringBuffer、StringBuilder的区别"></a>7、String 和StringBuffer、StringBuilder的区别</h3><p>Java提供了：String、StringBuffer和StringBuilder，它们都是CharSequence的实现类，都可以作为字符串使用。</p>
<p>String代表了字符序列不可变的字符串；而StringBuffer、StringBuilder都代表了字符序列可变的字符串。</p>
<p>StringBuffer、StringBuilder的区别是StringBuffer是线程安全的、性能略低，而StringBuilder是线程不安全的，适合单线程环境使用，性能较好。</p>
<h3 id="8、Collection-和-Collections的区别。"><a href="#8、Collection-和-Collections的区别。" class="headerlink" title="8、Collection 和 Collections的区别。"></a>8、Collection 和 Collections的区别。</h3><p>Collection是集合类（List、Set、Queue）的根接口。</p>
<p>Collections是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="9、说说-amp-和-amp-amp-的区别。"><a href="#9、说说-amp-和-amp-amp-的区别。" class="headerlink" title="9、说说&amp;和&amp;&amp;的区别。"></a>9、说说&amp;和&amp;&amp;的区别。</h3><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(a &gt;8 &amp;&amp; b &gt; 5)，当a小于等于8时，由于&amp;&amp;之前的表达式已经为false了，因此&amp;&amp;之后的表达式根本不会执行；</p>
<p>再例如if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，因此不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。</p>
<p>再例如if(x &gt; 8 &amp; ++y)与if(x &gt; 8 &amp;&amp; ++y )，当a小于等于8时，前一个表达式中y的值会增长；后一个表达式中y的值不会增加。</p>
<p>除此之外，&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 </p>
<h3 id="10、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#10、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="10、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?"></a>10、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?</h3><p>Overload是方法的重载</p>
<p>Override是方法的重写，也叫覆盖。</p>
<p>Overload要求两个方法具有方法名相同、形参列表不同的要求，返回值类型不能作为重载的条件。</p>
<p>Override要求子类方法与父类方法具有“两同两小一大”的要求。<strong>两同</strong>指：即父类方法、子类方法的方法名相同、形参列表相同；<strong>两小</strong>指：子类方法返回值类型要么是父类方法返回值类型的子类、要么与父类方法返回值类型相同；子类方法声明抛出的异常类型要么是父类方法声明抛出的异常类型的子类、要么与父类声明抛出的异常类型相同；<strong>一大</strong>指：子类方法的访问权限要么与父类方法的访问权限相同，要么比父类方法的访问权限更大。</p>
<p>Overloaded的方法是可以改变返回值的类型。</p>
<h3 id="11、Java如何跳出当前的多重嵌套循环？"><a href="#11、Java如何跳出当前的多重嵌套循环？" class="headerlink" title="11、Java如何跳出当前的多重嵌套循环？"></a>11、Java如何跳出当前的多重嵌套循环？</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，</p>
<p>  outer:</p>
<p>​    for(int i&#x3D;0;i&lt;10;i++)</p>
<p>​    {</p>
<p>​        for(int j&#x3D;0;j&lt;10;j++)</p>
<p>​        {</p>
<p>​            System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);</p>
<p>​            if(j &#x3D;&#x3D; 5) break ouer;</p>
<p>​        }</p>
<p>​    }</p>
<h3 id="12、switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#12、switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="12、switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>12、switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h3><p>在Java 7以前，在switch（expr1）中，expr1只能是一个整数表达式（但不包括long和Long）或者<strong>枚举常量</strong>，整数表达式可以是int基本类型或Integer包装类型，byte、short、char都可以自动转换为int，它们都可作为switch表达式。</p>
<p>从Java 7开始，switch表达式的可以使用String。</p>
<h3 id="13、String-s-x3D-new-String-“xyz”-创建了几个String-Object"><a href="#13、String-s-x3D-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="13、String s &#x3D; new String(“xyz”);创建了几个String Object?"></a>13、String s &#x3D; new String(“xyz”);创建了几个String Object?</h3><p>两个。一个是直接量的xyz对象；另一个是通过new Sting()构造器创建出来的String对象。</p>
<p>通常来说，应该尽量使用直接量的String对象，这样具有更好的性能。</p>
<h3 id="14、数组有没有length-这个方法-String有没有length-这个方法？"><a href="#14、数组有没有length-这个方法-String有没有length-这个方法？" class="headerlink" title="14、数组有没有length()这个方法? String有没有length()这个方法？"></a>14、数组有没有length()这个方法? String有没有length()这个方法？</h3><p>数组没有length()这个方法，有length的属性。String有length()方法。</p>
<h3 id="15、short-s1-x3D-1-s1-x3D-s1-1-有什么错-short-s1-x3D-1-s1-x3D-1-有什么错"><a href="#15、short-s1-x3D-1-s1-x3D-s1-1-有什么错-short-s1-x3D-1-s1-x3D-1-有什么错" class="headerlink" title="15、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?"></a>15、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?</h3><p>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。</p>
<p>对于short s1 &#x3D; 1; s1 +&#x3D; 1;由于 +&#x3D;运算符里已经包括了一个隐式的强制类型转换，因此Java会把s1+&#x3D;1计算后的结果进行隐式的强制类型转换，因此它不会有任何错误。 </p>
<h3 id="16、char型变量中能不能存储一个中文字符-为什么"><a href="#16、char型变量中能不能存储一个中文字符-为什么" class="headerlink" title="16、char型变量中能不能存储一个中文字符?为什么?"></a>16、char型变量中能不能存储一个中文字符?为什么?</h3><p>char型变量是用来存储Unicode编码的字符的，Unicode编码字符集中包含了汉字，因此char型变量中可以存储汉字。不过，如果某个特殊的汉字没有被包含在Unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。</p>
<p>char类型的变量占两个字节，而Unicode编码中每个字符也占两个字节，因此char类型类型的变量可以存储任何一个Unicode字符。</p>
<h3 id="17、用最有效率的方法算出2乘以8等于几"><a href="#17、用最有效率的方法算出2乘以8等于几" class="headerlink" title="17、用最有效率的方法算出2乘以8等于几?"></a>17、用最有效率的方法算出2乘以8等于几?</h3><p>2 &lt;&lt; 3</p>
<p>因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算CPU直接支持的，效率最高，所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</p>
<p>但需要注意的是，如果这个数字本身已经很大，比如本身已经是2的30次方了，此时再用这种位移运算就可能导致“溢出”，这样就得不到正确结果了。</p>
<h3 id="18、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#18、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="18、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>18、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：</p>
<p>final StringBuilder a&#x3D;new StringBuilder (“immutable”);</p>
<p>执行如下语句将报告编译错误：</p>
<p>a &#x3D; new StringBuilder (“”);</p>
<p>但如下语句则是完全正确的</p>
<p>a.append(“fkjava.org”); </p>
<p>有人希望在定义方法的形参时，通过final修饰符来阻止方法内部修改传进来的实参：</p>
<p>public void method(final StringBuilder param)</p>
<p>{</p>
<p>} </p>
<p>实际上这没有用，在该方法内部仍然可以增加如下代码来修改实参对象：</p>
<p>param.append(“fkjava.org”);</p>
<h3 id="19、”-x3D-x3D-”和equals方法究竟有什么区别？"><a href="#19、”-x3D-x3D-”和equals方法究竟有什么区别？" class="headerlink" title="19、”&#x3D;&#x3D;”和equals方法究竟有什么区别？"></a>19、”&#x3D;&#x3D;”和equals方法究竟有什么区别？</h3><p>&#x3D;&#x3D;操作符的功能有两个：</p>
<p>A．如果&#x3D;&#x3D;的两边都是基本类型变量、包装类对象所组成的表达式，&#x3D;&#x3D;用于比较两边的表达式的值是否相等——只要两边的表达式的值相等，即使数据类不同，该运算符也会返回true。</p>
<p>B．如果&#x3D;&#x3D;的两边是引用类型的变量，&#x3D;&#x3D;用于判断这两个引用类型的变量是否引用同一块内存，只有当它们引用同一块内存时，&#x3D;&#x3D;才会返回true。</p>
<p>而equals()则是一个java.lang.Object类的一个方法，因此任何Java对象都可调用该方法与其他对象进行比较。java.lang.Object类的equals方法的实现代码如下：</p>
<p>boolean equals(Object o)</p>
<p>{</p>
<p>​    return this&#x3D;&#x3D;o;</p>
<p>}</p>
<p>从上面代码可以看出，如果一个类没有重写java.lang.Object的equals()方法时，此时equals()方法的比较结果与&#x3D;&#x3D;的比较结果是相同的。</p>
<p>但Java允许任何类重写equals()方法，重写该方法就是让程序员来自己决定两个对象相等的标准——极端的情况下，我们完全可以设计出Person对象与Dog对象equals()比较返回true的情况——当然一般不会这么设计。</p>
<p>实际上重写equals()方法时通常会按如下格式：</p>
<p>​    public boolean equals(Object obj)</p>
<p>​    {</p>
<p>​        if (this &#x3D;&#x3D; obj)</p>
<p>​            return true;</p>
<p>​        if (obj &#x3D;&#x3D; null)</p>
<p>​            return false;</p>
<p>​        if (getClass() !&#x3D; obj.getClass())</p>
<p>​            return false;</p>
<p>​        Person other &#x3D; (Person) obj;</p>
<p>​        if (name &#x3D;&#x3D; null)</p>
<p>​        {</p>
<p>​            if (other.name !&#x3D; null)</p>
<p>​                return false;</p>
<p>​        }</p>
<p>​        else if (!name.equals(other.name))</p>
<p>​            return false;</p>
<p>​        if (pass &#x3D;&#x3D; null)</p>
<p>​        {</p>
<p>​            if (other.pass !&#x3D; null)</p>
<p>​                return false;</p>
<p>​        }</p>
<p>​        else if (!pass.equals(other.pass))</p>
<p>​            return false;</p>
<p>​        return true;</p>
<p>​    }</p>
<p>上面重写equals()方法用于判断两个Person对象是否“相等”，程序只要两个Person对象的name、pass相等，程序就可以把这两个Person对象当成相等——这是系统业务决定的。如果业务需要，我们也可以增加更多的参与判断的Field，当然也可以只根据name进行判断——只要两个Person的name相等，就认为两个Person相等，这都是由系统的业务决定。</p>
<p>总结起来就是一句话：开发者重写equals()方法就可以根据业务要求来决定两个对象是否“相等”。</p>
<h3 id="20、静态变量和实例变量的区别？"><a href="#20、静态变量和实例变量的区别？" class="headerlink" title="20、静态变量和实例变量的区别？"></a>20、静态变量和实例变量的区别？</h3><p>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p>
<p>在程序运行时的区别：实例变量属于一个对象，必须先创建实例对象，它的实例变量才会被分配空间，才能使用这个实例变量。静态变量则属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<p>例如，对于下面的程序： </p>
<p>public class VarTest</p>
<p>{</p>
<p>​    public static int staticVar &#x3D; 0; </p>
<p>​    public int instanceVar &#x3D; 0; </p>
<p>​    public VarTest ()</p>
<p>​    {</p>
<p>​        staticVar++;</p>
<p>​        instanceVar++;</p>
<p>​        System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);</p>
<p>​    }</p>
<p>}</p>
<p>上面程序中的staticVar变量随VarTest类初始化而分配内存、执行初始化的，以后无论创建多少个实例对象，不会再分配staticVar变量，因此用永远只有一个staticVar变量。</p>
<p>但instanceVar变量则是随着VarTest对象初始化而分配内存、执行初始化的，因此每创建一个实例对象，就会分配一个instanceVar，即可以分配多个instanceVar。因此上面程序中每创建一个VarTest对象，staticVar的值就会自加一，但每个VarTest对象的instanceVar最多只自加1。</p>
<h3 id="21、是否可以从一个static方法内部调用非static方法？"><a href="#21、是否可以从一个static方法内部调用非static方法？" class="headerlink" title="21、是否可以从一个static方法内部调用非static方法？"></a>21、是否可以从一个static方法内部调用非static方法？</h3><p>不可以。静态成员不能调用非静态成员。</p>
<p>非static方法属于对象，必须创建一个对象后，才可以在通过该对象来调用static方法。而static方法调用时不需要创建对象，通过类就可以调用该方法。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果允许从一个static方法中调用非static方法的调用，那个非static方法是没有调用对象的。因此Java不允许static方法内部调用非static方法。</p>
<h3 id="22、Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#22、Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="22、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>22、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h3><p>Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p>
<h3 id="23、请说出作用域public，private，protected，以及不写时的区别"><a href="#23、请说出作用域public，private，protected，以及不写时的区别" class="headerlink" title="23、请说出作用域public，private，protected，以及不写时的区别"></a>23、请说出作用域public，private，protected，以及不写时的区别</h3><p>这四个作用域的可见范围如下表所示。</p>
<p>作用域  当前类  同一package  子类  全局 </p>
<p>public   √    √       √    √</p>
<p>protected  √    √      √   ×</p>
<p>default   √    √       ×   ×</p>
<p>private   √    ×       ×   ×</p>
<p>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示default。</p>
<p>只要记住访问权限由小到大依次是private → default → protected → public，然后再记住Java存在的4个访问范围，就很容易画出上面的表格了。</p>
<h3 id="24、外部类能用private、protected修饰吗？内部类可以用private、protected修饰吗？"><a href="#24、外部类能用private、protected修饰吗？内部类可以用private、protected修饰吗？" class="headerlink" title="24、外部类能用private、protected修饰吗？内部类可以用private、protected修饰吗？"></a>24、外部类能用private、protected修饰吗？内部类可以用private、protected修饰吗？</h3><p>外部类不能用private、protected修饰不能。内部类能用private、protected修饰不能。</p>
<p>外部类的上一级程序单位是包，因此它只有两个使用范围：包内和包外，因此它只能用public（表示可以在全局位置使用）和默认修饰符（default，表示只能被同一个包的其他类使用）修饰。</p>
<h3 id="25、一个类定义多个重载方法，参数分别是int-char-和double，然后将double-x-x3D-2，传递进去，会选择哪个方法？"><a href="#25、一个类定义多个重载方法，参数分别是int-char-和double，然后将double-x-x3D-2，传递进去，会选择哪个方法？" class="headerlink" title="25、一个类定义多个重载方法，参数分别是int ,char,和double，然后将double x &#x3D; 2，传递进去，会选择哪个方法？"></a>25、一个类定义多个重载方法，参数分别是int ,char,和double，然后将double x &#x3D; 2，传递进去，会选择哪个方法？</h3><p>选择参数类型为double的方法。</p>
<h3 id="26、说说has-a与is-a的区别。"><a href="#26、说说has-a与is-a的区别。" class="headerlink" title="26、说说has a与is a的区别。"></a>26、说说has a与is a的区别。</h3><p>is a是典型的“一般到特殊”的关系，也就是典型的继承关系。例如Apple is a Fruit。那么Apple是一种特殊的Fruit，也就是说Apple继承了Fruit。</p>
<p>has a是典型的“组合”关系。比如Wolf has a Leg，也就是Leg组合成了Wolf。</p>
<p>需要指出的是：由于继承会造成了对父类的破坏，因此有时候可以通过组合来代替的继承。使用继承的好处：程序语义更好理解。坏处是：子类可能重写父类方法，不利于父类封装；使用组合则造成语义的混淆，但组合类不会重写被组合类的方法，因此更利于被复合类的封装。</p>
<h3 id="27、ClassLoader如何加载class-。"><a href="#27、ClassLoader如何加载class-。" class="headerlink" title="27、ClassLoader如何加载class 。"></a>27、ClassLoader如何加载class 。</h3><p>  jvm里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap类加载负责加载jre&#x2F;lib&#x2F;rt.jar中的类， 我们平时用的jdk中的类都位于rt.jar中。extclassloader负责加载jar&#x2F;lib&#x2F;ext&#x2F;*.jar中的类，appclassloader负责classpath指定的目录或jar中的类。除了bootstrap之外，其他的类加载器本身也都是java类，它们的父类是ClassLoader。</p>
<p>4.抽象类的作用</p>
<h3 id="28、GC是什么-为什么要有GC"><a href="#28、GC是什么-为什么要有GC" class="headerlink" title="28、GC是什么? 为什么要有GC?"></a>28、GC是什么? 为什么要有GC?</h3><p>GC是垃圾收集的意思（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p>
<p>Java的System类和Runtime类都提供了“通知”程序进行垃圾回收的方法，例如如下代码：</p>
<p>Systme.gc();</p>
<p>或</p>
<p>Runtime.getInstance().gc();</p>
<p>但这两个方法只是“通知”Java进行垃圾回收，但实际上JVM何时进行垃圾回收，还是由JVM自己决定。</p>
<h3 id="29、垃圾回收的优点和原理。并考虑2种回收机制。"><a href="#29、垃圾回收的优点和原理。并考虑2种回收机制。" class="headerlink" title="29、垃圾回收的优点和原理。并考虑2种回收机制。"></a>29、垃圾回收的优点和原理。并考虑2种回收机制。</h3><p>传统的C&#x2F;C++等编程语言，需要程序员负责回收已经分配的内存。显式进行垃圾回收是一件比较困难的事情，因为程序员并不总是知道内存应该何时被释放。如果一些分配出去的内存得不到及时回收，就会引起系统运行速度下降，甚至导致程序瘫痪，这种现象被称为内存泄漏。总体而言，显式进行垃圾回收主要有如下两个缺点：</p>
<p>A．程序忘记及时回收无用内存，从而导致内存泄漏，降低系统性能。</p>
<p>B．程序错误地回收程序核心类库的内存，从而导致系统崩溃。</p>
<p>与C&#x2F;C++程序不同，Java语言不需要程序员直接控制内存回收，Java程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收（Garbage Collection，也被称为GC）。通常JRE会提供一条后台线程来进行检测和控制，一般都是在CPU空闲或内存不足时自动进行垃圾回收，而程序员无法精确控制垃圾回收的时间和顺序等。</p>
<p>实际上，垃圾回收机制不可能实时检测到每个Java对象的状态，当一个对象失去引用后，它也不会被立即回收，只有等接下来垃圾回收器运行时才会被回收。</p>
<p>对于一个垃圾回收器的设计算法来说，大致有如下可供选择的设计：</p>
<p>A．串行回收（Serial）和并行回收（Parallel）：串行回收就是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作；而并行回收就是把整个回收工作拆分成多部分，每个部分由一个CPU负责，从而让多个CPU并行回收，并行回收的执行效率很高，但复杂度增加，另外也有其他一些副作用，比如内存碎片会增加。 </p>
<p>B．并发执行（Concurrent）和应用程序停止（Stop-the-world）：。Stop-the-world的垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾回收需要解决和应用程序的执行冲突（应用程序可能会在垃圾回收的过称中修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world更好，而且执行时也需要更多的堆内存。</p>
<p>C．压缩（Compacting）和不压缩（Non-compacting）和复制（Copying）：为了减少内存碎片，支持压缩的垃圾回收器会把所有的活对象搬迁到一起，然后将之前占用的内存全部回收。不压缩式的垃圾回收器只是回收内存，这样回收回来的内存不可能是连续的，因此将会有较多的内存碎片。较之压缩式的垃圾回收，不压缩式的垃圾回收回收内存快了，而分配内存时就会更慢，而且无法解决内存碎片的问题。复制式的垃圾回收会将所有可达对象复制到另一块相同的内存中，这种方式的优点是垃圾及回收过程不会产生内存碎片，但缺点也很明显，需要拷贝数据和额外的内存。</p>
<h3 id="30、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#30、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="30、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>30、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><p>对于Java程序中对象而言，如果这个对象没有任何引用变量引用它，那么这个对象将不可能被程序访问，因此可认为它是垃圾；只要有一个以上的引用变量引用该对象，该对象就不会被垃圾回收。</p>
<p>对于Java的垃圾回收器来说，它使用有向图来记录和管理堆内存中的所有对象，通过这个有向图就可以识别哪些对象是“可达的”（有引用变量引用它就是可达的），哪些对象是“不可达的”（没有引用变量引用它就是不可达的），所有“不可达”对象都是可被垃圾回收的。</p>
<p>但对于如下程序：</p>
<p>class A</p>
<p>{</p>
<p>​    B b;</p>
<p>}</p>
<p>class B</p>
<p>{</p>
<p>​    A a;</p>
<p>}</p>
<p>public class Test</p>
<p>{</p>
<p>​    public static void main(String[] args)</p>
<p>​    {</p>
<p>​        A a &#x3D; new A();</p>
<p>​        a.b &#x3D; new B();</p>
<p>​        a.b.a &#x3D; a;</p>
<p>​        a &#x3D; null;</p>
<p>​    }</p>
<p>}</p>
<p>上面程序中A对象、B对象，它们都“相互”引用，A对象的b属性引用B对象，而B对象的a属性引用A对象，但实际上没有引用变量引用A对象、B对象，因此它们在有向图中依然是不可达的，因此也会被当成垃圾处理。</p>
<p>程序员可以手动执行System.gc()，通知GC运行，但这只是一个通知，而JVM依然有权决定何时进行垃圾回收。 </p>
<h3 id="31、什么时候用assert。"><a href="#31、什么时候用assert。" class="headerlink" title="31、什么时候用assert。"></a>31、什么时候用assert。</h3><p>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。</p>
<p>Java的assert是关键字。</p>
<p>public class TestAssert</p>
<p>{</p>
<p>  public static void main(String[] args) </p>
<p>  {</p>
<p>​     int a &#x3D; 5;</p>
<p>​     &#x2F;&#x2F;断言a&gt;3</p>
<p>​     assert a &gt; 3;</p>
<p>​     &#x2F;&#x2F;断言a&lt;3,否则显示a不小于3，且a的值为：” + a</p>
<p>​     assert a &lt; 3 : “a不小于3，且a的值为：” + a;</p>
<p>  }</p>
<p>}</p>
<p>从上面代码可以看出，assert的两个基本用法如下：</p>
<p>assert logicExp;</p>
<p>asert logicExp : expr;</p>
<p>A．第一个直接进行断言，</p>
<p>B．第二个也是进行断言，但当断言失败失败时显示特定信息。</p>
<p>最后要指出：</p>
<p>虽然assert是JDK1.4新增的关键字，但有一点非常重要：</p>
<p>java命令默认不启动断言，</p>
<p>为了启动用户断言，应该在运行java命令时增加-ea（Enable Assert）选项。</p>
<p>为了启动系统断言，应该在运行java命令时增加-esa（Enable System Assert）选项。</p>
<h3 id="32、Java中会存在内存泄漏吗，请简单描述。"><a href="#32、Java中会存在内存泄漏吗，请简单描述。" class="headerlink" title="32、Java中会存在内存泄漏吗，请简单描述。"></a>32、Java中会存在内存泄漏吗，请简单描述。</h3><p>为了搞清楚Java程序是否有内存泄露存在，我们首先了解一下什么是内存泄露：程序运行过程中会不断地分配内存空间；那些不再使用的内存空间应该即时回收它们，从而保证系统可以再次使用这些内存。如果存在无用的内存没有被回收回来，那就是内存泄露。</p>
<p>对于Java程序而言，只要Java对象一直处于可达状态，垃圾回收机制就不会回收它们——即使它们对于程序来说已经变成了垃圾（程序再也不需要它们了）；但对于垃圾回收机制来说，它们还不是垃圾（还处于可达状态），因此不能回收。</p>
<p>看ArrayList中remove(int index)方法的源代码，程序如下：</p>
<p>public E remove(int index) </p>
<p>{</p>
<p>​    &#x2F;&#x2F;检查index索引是否越界</p>
<p>​    RangeCheck(index);</p>
<p>​    &#x2F;&#x2F;使修改次数加1</p>
<p>​    modCount++;</p>
<p>​    &#x2F;&#x2F;获取被删除的元素</p>
<p>​    E oldValue &#x3D; (E)elementData[index];</p>
<p>​    int numMoved &#x3D; size - index - 1;</p>
<p>​    &#x2F;&#x2F;整体搬家</p>
<p>​    if (numMoved &gt; 0)</p>
<p>​        System.arraycopy(elementData, index+1</p>
<p>​            , elementData, index, numMoved);</p>
<p>​    &#x2F;&#x2F;将ArrayList的size减1，</p>
<p>​    &#x2F;&#x2F;并将最后一个数组赋为null，让垃圾回收机制回收最后一个元素</p>
<p>​    elementData[–size] &#x3D; null;</p>
<p>​    return oldValue;</p>
<p>}</p>
<p>上面程序中粗体字代码elementData[–size] &#x3D; null;就是为了避免垃圾回收机制而书写的代码，如果没有这行代码，这个方法就会产生内存泄露——每删除一个对象，但该对象所占用的内存空间却不会释放。</p>
<h3 id="33、能不能自己写个类，也叫java-lang-String？"><a href="#33、能不能自己写个类，也叫java-lang-String？" class="headerlink" title="33、能不能自己写个类，也叫java.lang.String？"></a>33、能不能自己写个类，也叫java.lang.String？</h3><p>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。</p>
<p>但在Tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF&#x2F;classess目录中的类，然后才委托上级的类加载器加载，如果我们在Tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。</p>
<h3 id="34、ArrayList如何实现插入的数据按自定义的方式有序存放"><a href="#34、ArrayList如何实现插入的数据按自定义的方式有序存放" class="headerlink" title="34、ArrayList如何实现插入的数据按自定义的方式有序存放"></a>34、ArrayList如何实现插入的数据按自定义的方式有序存放</h3><p>编程思路是：实现一个类对ArrayList进行包装，当程序试图向ArrayList中放入数据时，程序将先检查该元素与ArrayList集合中其他元素的大小，然后将该元素插入到指定位置。</p>
<p>class MyBean implements Comparable{</p>
<p>​    public int compareTo(Object obj){</p>
<p>​        if(! obj instanceof MyBean)</p>
<p>​            throw new ClassCastException()。</p>
<p>​        MyBean other &#x3D; (MyBean) obj;</p>
<p>​        return age &gt; other.age?1:age&#x3D;&#x3D; other.age?0:-1;</p>
<p>​    }</p>
<p>}</p>
<p>class MyTreeSet {</p>
<p>​    private ArrayList datas &#x3D; new ArrayList();</p>
<p>​    </p>
<p>​    public void add(Object obj){</p>
<p>​        for(int i&#x3D;0;i&lt;datas.size();i++){</p>
<p>​            if(obj.compareTo(datas.get(i) !&#x3D; 1){</p>
<p>​                datas.add(i,obj);</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<h3 id="35-序列化接口的id有什么用？"><a href="#35-序列化接口的id有什么用？" class="headerlink" title="35.序列化接口的id有什么用？"></a>35.序列化接口的id有什么用？</h3><p>反序列化Java对象时必须提供该对象的class文件，现在的问题是随着项目的升级，系统的class文件也会升级，Java如何保证两个class文件的兼容性？</p>
<p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID值，该Field值用于标识该Java类的序列化版本，也就是说如果一个类升级后，只要它的serialVersionUID    Field值保持不变，序列化机制也会把它们当成同一个序列化版本。</p>
<h3 id="36、hashCode-方法的作用？"><a href="#36、hashCode-方法的作用？" class="headerlink" title="36、hashCode()方法的作用？"></a>36、hashCode()方法的作用？</h3><p>hashCode()方法与equals()方法相似，都是来自java.lang.Object类的方法，都允许用户定义的子类重写这两个方法。</p>
<p>一般来说，equals这个方法是给用户调用的，如果你想根据自己的业务规则来判断2个对象是否相等，你可以重写equals()方法。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。</p>
<p>而hashCode()方法通常是给其他类来调用的，比如当我们要把两个对象放入HashSet时，由于HashSet要求两个对象不能相等，而HashSet判断两个对象是否相等的标准是通过equals()比较返回false、或两个对象的hashCode()方法返回值不相等——只要满足任意一个条件都可会认为两个对象不相等。</p>
<p>从这个角度来看，我们可以把hashCode()方法的返回值当成这个对象的“标识符”，如果两个对象的hashCode()相等，即可认为这两个对象是相等的。因此当我们重写一个类的equals()方法时，也应该重写它的hashCode()方法，而且这两个方法判断两个对象相等的标准也应该是一样的。</p>
<p>）</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/Hexo/categories/java%E5%9F%BA%E7%A1%80%F0%9F%90%B1%E2%80%8D%F0%9F%91%A4/" class="category-chain-item">java基础🐱‍👤</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/Hexo/tags/Java%E5%9F%BA%E7%A1%80/">#Java基础</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>《Java基础面试题》</div>
      <div>https://1902756969.github.io/Hexo/2021/03/21/《Java基础面试题》/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>星</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年3月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Hexo/2021/03/23/%E9%9B%86%E5%90%8801/" title="Collection集合">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Collection集合</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Hexo/2021/03/21/switch&amp;%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/" title="switch&amp;循环语句">
                        <span class="hidden-mobile">switch&amp;循环语句</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/Hexo/js/events.js" ></script>
<script  src="/Hexo/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/Hexo/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/Hexo/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/Hexo/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/Hexo/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/Hexo/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":120,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
